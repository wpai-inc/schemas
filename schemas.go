// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schemas

import "encoding/json"
import "fmt"
import "reflect"

// An action is an object that can be executed in WordPress to perform a particular
// task according to its capabilities.
type ActionSchemaJson map[string]interface{}

type BaseAction struct {
	// The capability of the Action defines what it's able to do when executed by the
	// WordPress client.
	Capability string `json:"capability" yaml:"capability" mapstructure:"capability"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BaseAction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["capability"]; raw != nil && !ok {
		return fmt.Errorf("field capability in BaseAction: required")
	}
	type Plain BaseAction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BaseAction(plain)
	return nil
}

type CodeAction interface{}

type MessageAction struct {
	// Buttons corresponds to the JSON schema field "buttons".
	Buttons []MessageActionButtonsElem `json:"buttons,omitempty" yaml:"buttons,omitempty" mapstructure:"buttons,omitempty"`

	// Capability corresponds to the JSON schema field "capability".
	Capability interface{} `json:"capability,omitempty" yaml:"capability,omitempty" mapstructure:"capability,omitempty"`

	// Graph corresponds to the JSON schema field "graph".
	Graph *MessageActionGraph `json:"graph,omitempty" yaml:"graph,omitempty" mapstructure:"graph,omitempty"`

	// The text of the message in markdown.
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

type MessageActionButtonsElem struct {
	// Label corresponds to the JSON schema field "label".
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// Level corresponds to the JSON schema field "level".
	Level *MessageActionButtonsElemLevel `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

type MessageActionButtonsElemLevel string

const MessageActionButtonsElemLevelDanger MessageActionButtonsElemLevel = "danger"
const MessageActionButtonsElemLevelPrimary MessageActionButtonsElemLevel = "primary"
const MessageActionButtonsElemLevelSecondary MessageActionButtonsElemLevel = "secondary"
const MessageActionButtonsElemLevelSuccess MessageActionButtonsElemLevel = "success"

var enumValues_MessageActionButtonsElemLevel = []interface{}{
	"primary",
	"secondary",
	"danger",
	"success",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageActionButtonsElemLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MessageActionButtonsElemLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MessageActionButtonsElemLevel, v)
	}
	*j = MessageActionButtonsElemLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageActionButtonsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in MessageActionButtonsElem: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in MessageActionButtonsElem: required")
	}
	type Plain MessageActionButtonsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MessageActionButtonsElem(plain)
	return nil
}

type MessageActionGraph struct {
	// Data corresponds to the JSON schema field "data".
	Data []MessageActionGraphDataElem `json:"data" yaml:"data" mapstructure:"data"`

	// GraphType corresponds to the JSON schema field "graphType".
	GraphType string `json:"graphType" yaml:"graphType" mapstructure:"graphType"`

	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

type MessageActionGraphDataElem struct {
	// Label corresponds to the JSON schema field "label".
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageActionGraphDataElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in MessageActionGraphDataElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in MessageActionGraphDataElem: required")
	}
	type Plain MessageActionGraphDataElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MessageActionGraphDataElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageActionGraph) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in MessageActionGraph: required")
	}
	type Plain MessageActionGraph
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["graphType"]; !ok || v == nil {
		plain.GraphType = "bar"
	}
	*j = MessageActionGraph(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageAction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in MessageAction: required")
	}
	type Plain MessageAction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MessageAction(plain)
	return nil
}

type NavigateAction interface{}

// An object that identifies a WordPress page and its capabilities.
type NavigationTargetSchemaJson struct {
	// An array of objects representing the page's capabilities.
	Capabilities []NavigationTargetSchemaJsonCapabilitiesElem `json:"capabilities" yaml:"capabilities" mapstructure:"capabilities"`

	// Indicates whether the page is a single-page application (SPA) or not.
	IsSpa bool `json:"is_spa" yaml:"is_spa" mapstructure:"is_spa"`

	// The page's reason for being, in no more than 280 characters.
	Purpose string `json:"purpose" yaml:"purpose" mapstructure:"purpose"`
}

type NavigationTargetSchemaJsonCapabilitiesElem struct {
	// The CSS selector for the element that performs the capability.
	ActingElementSelector *string `json:"acting_element_selector,omitempty" yaml:"acting_element_selector,omitempty" mapstructure:"acting_element_selector,omitempty"`

	// A description of what the capability does.
	CapabilityDescription string `json:"capability_description" yaml:"capability_description" mapstructure:"capability_description"`

	// The type of element (e.g., form, input, button, a).
	ElementType string `json:"element_type" yaml:"element_type" mapstructure:"element_type"`

	// Whether the element expects a payload or not. For example, an anchor tag or
	// button does not expect a payload, but a form or input does.
	HasPayload bool `json:"has_payload" yaml:"has_payload" mapstructure:"has_payload"`

	// A description of what the element expects as a payload (optional).
	PayloadDescription *string `json:"payload_description,omitempty" yaml:"payload_description,omitempty" mapstructure:"payload_description,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NavigationTargetSchemaJsonCapabilitiesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["capability_description"]; raw != nil && !ok {
		return fmt.Errorf("field capability_description in NavigationTargetSchemaJsonCapabilitiesElem: required")
	}
	if _, ok := raw["element_type"]; raw != nil && !ok {
		return fmt.Errorf("field element_type in NavigationTargetSchemaJsonCapabilitiesElem: required")
	}
	if _, ok := raw["has_payload"]; raw != nil && !ok {
		return fmt.Errorf("field has_payload in NavigationTargetSchemaJsonCapabilitiesElem: required")
	}
	type Plain NavigationTargetSchemaJsonCapabilitiesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NavigationTargetSchemaJsonCapabilitiesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NavigationTargetSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["capabilities"]; raw != nil && !ok {
		return fmt.Errorf("field capabilities in NavigationTargetSchemaJson: required")
	}
	if _, ok := raw["is_spa"]; raw != nil && !ok {
		return fmt.Errorf("field is_spa in NavigationTargetSchemaJson: required")
	}
	if _, ok := raw["purpose"]; raw != nil && !ok {
		return fmt.Errorf("field purpose in NavigationTargetSchemaJson: required")
	}
	type Plain NavigationTargetSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Purpose) > 280 {
		return fmt.Errorf("field %s length: must be <= %d", "purpose", 280)
	}
	*j = NavigationTargetSchemaJson(plain)
	return nil
}

type RunAction interface{}

type SiteSchemaJson struct {
	// Info corresponds to the JSON schema field "info".
	Info SiteSchemaJsonInfo `json:"info" yaml:"info" mapstructure:"info"`

	// Status corresponds to the JSON schema field "status".
	Status SiteSchemaJsonStatus `json:"status" yaml:"status" mapstructure:"status"`
}

type SiteSchemaJsonInfo struct {
	// ActivePlugins corresponds to the JSON schema field "activePlugins".
	ActivePlugins []SiteSchemaJsonInfoActivePluginsElem `json:"activePlugins" yaml:"activePlugins" mapstructure:"activePlugins"`

	// ActiveTheme corresponds to the JSON schema field "activeTheme".
	ActiveTheme SiteSchemaJsonInfoActiveTheme `json:"activeTheme" yaml:"activeTheme" mapstructure:"activeTheme"`

	// CustomPostTypesAndTaxonomies corresponds to the JSON schema field
	// "customPostTypesAndTaxonomies".
	CustomPostTypesAndTaxonomies SiteSchemaJsonInfoCustomPostTypesAndTaxonomies `json:"customPostTypesAndTaxonomies" yaml:"customPostTypesAndTaxonomies" mapstructure:"customPostTypesAndTaxonomies"`

	// DatabaseConfiguration corresponds to the JSON schema field
	// "databaseConfiguration".
	DatabaseConfiguration SiteSchemaJsonInfoDatabaseConfiguration `json:"databaseConfiguration" yaml:"databaseConfiguration" mapstructure:"databaseConfiguration"`

	// DatabaseSchema corresponds to the JSON schema field "databaseSchema".
	DatabaseSchema SiteSchemaJsonInfoDatabaseSchema `json:"databaseSchema" yaml:"databaseSchema" mapstructure:"databaseSchema"`

	// Debug log entries since the last saved state, keeping only unique logs
	DebugLog []SiteSchemaJsonInfoDebugLogElem `json:"debugLog" yaml:"debugLog" mapstructure:"debugLog"`

	// DirectoriesAndSizes corresponds to the JSON schema field "directoriesAndSizes".
	DirectoriesAndSizes SiteSchemaJsonInfoDirectoriesAndSizes `json:"directoriesAndSizes" yaml:"directoriesAndSizes" mapstructure:"directoriesAndSizes"`

	// FilesystemPermissions corresponds to the JSON schema field
	// "filesystemPermissions".
	FilesystemPermissions SiteSchemaJsonInfoFilesystemPermissions `json:"filesystemPermissions" yaml:"filesystemPermissions" mapstructure:"filesystemPermissions"`

	// InactivePlugins corresponds to the JSON schema field "inactivePlugins".
	InactivePlugins []SiteSchemaJsonInfoInactivePluginsElem `json:"inactivePlugins" yaml:"inactivePlugins" mapstructure:"inactivePlugins"`

	// InactiveThemes corresponds to the JSON schema field "inactiveThemes".
	InactiveThemes []SiteSchemaJsonInfoInactiveThemesElem `json:"inactiveThemes" yaml:"inactiveThemes" mapstructure:"inactiveThemes"`

	// MediaHandling corresponds to the JSON schema field "mediaHandling".
	MediaHandling SiteSchemaJsonInfoMediaHandling `json:"mediaHandling" yaml:"mediaHandling" mapstructure:"mediaHandling"`

	// ServerEnvironment corresponds to the JSON schema field "serverEnvironment".
	ServerEnvironment SiteSchemaJsonInfoServerEnvironment `json:"serverEnvironment" yaml:"serverEnvironment" mapstructure:"serverEnvironment"`

	// Wordpress corresponds to the JSON schema field "wordpress".
	Wordpress SiteSchemaJsonInfoWordpress `json:"wordpress" yaml:"wordpress" mapstructure:"wordpress"`

	// WordpressConstants corresponds to the JSON schema field "wordpressConstants".
	WordpressConstants SiteSchemaJsonInfoWordpressConstants `json:"wordpressConstants" yaml:"wordpressConstants" mapstructure:"wordpressConstants"`
}

type SiteSchemaJsonInfoActivePluginsElem struct {
	// Author corresponds to the JSON schema field "author".
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// AutoUpdates corresponds to the JSON schema field "autoUpdates".
	AutoUpdates bool `json:"autoUpdates" yaml:"autoUpdates" mapstructure:"autoUpdates"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoActivePluginsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in SiteSchemaJsonInfoActivePluginsElem: required")
	}
	if _, ok := raw["autoUpdates"]; raw != nil && !ok {
		return fmt.Errorf("field autoUpdates in SiteSchemaJsonInfoActivePluginsElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SiteSchemaJsonInfoActivePluginsElem: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SiteSchemaJsonInfoActivePluginsElem: required")
	}
	type Plain SiteSchemaJsonInfoActivePluginsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoActivePluginsElem(plain)
	return nil
}

type SiteSchemaJsonInfoActiveTheme struct {
	// Author corresponds to the JSON schema field "author".
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// AuthorWebsite corresponds to the JSON schema field "authorWebsite".
	AuthorWebsite *string `json:"authorWebsite,omitempty" yaml:"authorWebsite,omitempty" mapstructure:"authorWebsite,omitempty"`

	// AutoUpdates corresponds to the JSON schema field "autoUpdates".
	AutoUpdates bool `json:"autoUpdates" yaml:"autoUpdates" mapstructure:"autoUpdates"`

	// DirectoryLocation corresponds to the JSON schema field "directoryLocation".
	DirectoryLocation string `json:"directoryLocation" yaml:"directoryLocation" mapstructure:"directoryLocation"`

	// Features corresponds to the JSON schema field "features".
	Features []string `json:"features" yaml:"features" mapstructure:"features"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// ParentTheme corresponds to the JSON schema field "parentTheme".
	ParentTheme string `json:"parentTheme" yaml:"parentTheme" mapstructure:"parentTheme"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoActiveTheme) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in SiteSchemaJsonInfoActiveTheme: required")
	}
	if _, ok := raw["autoUpdates"]; raw != nil && !ok {
		return fmt.Errorf("field autoUpdates in SiteSchemaJsonInfoActiveTheme: required")
	}
	if _, ok := raw["directoryLocation"]; raw != nil && !ok {
		return fmt.Errorf("field directoryLocation in SiteSchemaJsonInfoActiveTheme: required")
	}
	if _, ok := raw["features"]; raw != nil && !ok {
		return fmt.Errorf("field features in SiteSchemaJsonInfoActiveTheme: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SiteSchemaJsonInfoActiveTheme: required")
	}
	if _, ok := raw["parentTheme"]; raw != nil && !ok {
		return fmt.Errorf("field parentTheme in SiteSchemaJsonInfoActiveTheme: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SiteSchemaJsonInfoActiveTheme: required")
	}
	type Plain SiteSchemaJsonInfoActiveTheme
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoActiveTheme(plain)
	return nil
}

type SiteSchemaJsonInfoCustomPostTypesAndTaxonomies map[string]interface{}

type SiteSchemaJsonInfoDatabaseConfiguration struct {
	// Charset corresponds to the JSON schema field "charset".
	Charset string `json:"charset" yaml:"charset" mapstructure:"charset"`

	// ClientVersion corresponds to the JSON schema field "clientVersion".
	ClientVersion string `json:"clientVersion" yaml:"clientVersion" mapstructure:"clientVersion"`

	// Collation corresponds to the JSON schema field "collation".
	Collation string `json:"collation" yaml:"collation" mapstructure:"collation"`

	// DatabaseCredentials corresponds to the JSON schema field "databaseCredentials".
	DatabaseCredentials SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials `json:"databaseCredentials" yaml:"databaseCredentials" mapstructure:"databaseCredentials"`

	// Extension corresponds to the JSON schema field "extension".
	Extension string `json:"extension" yaml:"extension" mapstructure:"extension"`

	// MaxConnections corresponds to the JSON schema field "maxConnections".
	MaxConnections int `json:"maxConnections" yaml:"maxConnections" mapstructure:"maxConnections"`

	// MaxPacketSize corresponds to the JSON schema field "maxPacketSize".
	MaxPacketSize int `json:"maxPacketSize" yaml:"maxPacketSize" mapstructure:"maxPacketSize"`

	// ServerVersion corresponds to the JSON schema field "serverVersion".
	ServerVersion string `json:"serverVersion" yaml:"serverVersion" mapstructure:"serverVersion"`
}

type SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials struct {
	// Host corresponds to the JSON schema field "host".
	Host string `json:"host" yaml:"host" mapstructure:"host"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username" mapstructure:"username"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["host"]; raw != nil && !ok {
		return fmt.Errorf("field host in SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials: required")
	}
	if _, ok := raw["username"]; raw != nil && !ok {
		return fmt.Errorf("field username in SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials: required")
	}
	type Plain SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDatabaseConfigurationDatabaseCredentials(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDatabaseConfiguration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["charset"]; raw != nil && !ok {
		return fmt.Errorf("field charset in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	if _, ok := raw["clientVersion"]; raw != nil && !ok {
		return fmt.Errorf("field clientVersion in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	if _, ok := raw["collation"]; raw != nil && !ok {
		return fmt.Errorf("field collation in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	if _, ok := raw["databaseCredentials"]; raw != nil && !ok {
		return fmt.Errorf("field databaseCredentials in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	if _, ok := raw["extension"]; raw != nil && !ok {
		return fmt.Errorf("field extension in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	if _, ok := raw["maxConnections"]; raw != nil && !ok {
		return fmt.Errorf("field maxConnections in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	if _, ok := raw["maxPacketSize"]; raw != nil && !ok {
		return fmt.Errorf("field maxPacketSize in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	if _, ok := raw["serverVersion"]; raw != nil && !ok {
		return fmt.Errorf("field serverVersion in SiteSchemaJsonInfoDatabaseConfiguration: required")
	}
	type Plain SiteSchemaJsonInfoDatabaseConfiguration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDatabaseConfiguration(plain)
	return nil
}

type SiteSchemaJsonInfoDatabaseSchema struct {
	// RowCounts corresponds to the JSON schema field "rowCounts".
	RowCounts SiteSchemaJsonInfoDatabaseSchemaRowCounts `json:"rowCounts" yaml:"rowCounts" mapstructure:"rowCounts"`

	// Structure corresponds to the JSON schema field "structure".
	Structure SiteSchemaJsonInfoDatabaseSchemaStructure `json:"structure" yaml:"structure" mapstructure:"structure"`

	// Tables corresponds to the JSON schema field "tables".
	Tables []SiteSchemaJsonInfoDatabaseSchemaTablesElem `json:"tables" yaml:"tables" mapstructure:"tables"`
}

type SiteSchemaJsonInfoDatabaseSchemaRowCounts map[string]interface{}

type SiteSchemaJsonInfoDatabaseSchemaStructure map[string]interface{}

type SiteSchemaJsonInfoDatabaseSchemaTablesElem map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDatabaseSchema) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["rowCounts"]; raw != nil && !ok {
		return fmt.Errorf("field rowCounts in SiteSchemaJsonInfoDatabaseSchema: required")
	}
	if _, ok := raw["structure"]; raw != nil && !ok {
		return fmt.Errorf("field structure in SiteSchemaJsonInfoDatabaseSchema: required")
	}
	if _, ok := raw["tables"]; raw != nil && !ok {
		return fmt.Errorf("field tables in SiteSchemaJsonInfoDatabaseSchema: required")
	}
	type Plain SiteSchemaJsonInfoDatabaseSchema
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDatabaseSchema(plain)
	return nil
}

type SiteSchemaJsonInfoDebugLogElem map[string]interface{}

type SiteSchemaJsonInfoDirectoriesAndSizes struct {
	// DatabaseSize corresponds to the JSON schema field "databaseSize".
	DatabaseSize float64 `json:"databaseSize" yaml:"databaseSize" mapstructure:"databaseSize"`

	// PluginsDirectory corresponds to the JSON schema field "pluginsDirectory".
	PluginsDirectory SiteSchemaJsonInfoDirectoriesAndSizesPluginsDirectory `json:"pluginsDirectory" yaml:"pluginsDirectory" mapstructure:"pluginsDirectory"`

	// ThemesDirectory corresponds to the JSON schema field "themesDirectory".
	ThemesDirectory SiteSchemaJsonInfoDirectoriesAndSizesThemesDirectory `json:"themesDirectory" yaml:"themesDirectory" mapstructure:"themesDirectory"`

	// TotalInstallationSize corresponds to the JSON schema field
	// "totalInstallationSize".
	TotalInstallationSize float64 `json:"totalInstallationSize" yaml:"totalInstallationSize" mapstructure:"totalInstallationSize"`

	// UploadsDirectory corresponds to the JSON schema field "uploadsDirectory".
	UploadsDirectory SiteSchemaJsonInfoDirectoriesAndSizesUploadsDirectory `json:"uploadsDirectory" yaml:"uploadsDirectory" mapstructure:"uploadsDirectory"`

	// WordpressDirectory corresponds to the JSON schema field "wordpressDirectory".
	WordpressDirectory SiteSchemaJsonInfoDirectoriesAndSizesWordpressDirectory `json:"wordpressDirectory" yaml:"wordpressDirectory" mapstructure:"wordpressDirectory"`
}

type SiteSchemaJsonInfoDirectoriesAndSizesPluginsDirectory struct {
	// Location corresponds to the JSON schema field "location".
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDirectoriesAndSizesPluginsDirectory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in SiteSchemaJsonInfoDirectoriesAndSizesPluginsDirectory: required")
	}
	if _, ok := raw["size"]; raw != nil && !ok {
		return fmt.Errorf("field size in SiteSchemaJsonInfoDirectoriesAndSizesPluginsDirectory: required")
	}
	type Plain SiteSchemaJsonInfoDirectoriesAndSizesPluginsDirectory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDirectoriesAndSizesPluginsDirectory(plain)
	return nil
}

type SiteSchemaJsonInfoDirectoriesAndSizesThemesDirectory struct {
	// Location corresponds to the JSON schema field "location".
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDirectoriesAndSizesThemesDirectory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in SiteSchemaJsonInfoDirectoriesAndSizesThemesDirectory: required")
	}
	if _, ok := raw["size"]; raw != nil && !ok {
		return fmt.Errorf("field size in SiteSchemaJsonInfoDirectoriesAndSizesThemesDirectory: required")
	}
	type Plain SiteSchemaJsonInfoDirectoriesAndSizesThemesDirectory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDirectoriesAndSizesThemesDirectory(plain)
	return nil
}

type SiteSchemaJsonInfoDirectoriesAndSizesUploadsDirectory struct {
	// Location corresponds to the JSON schema field "location".
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDirectoriesAndSizesUploadsDirectory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in SiteSchemaJsonInfoDirectoriesAndSizesUploadsDirectory: required")
	}
	if _, ok := raw["size"]; raw != nil && !ok {
		return fmt.Errorf("field size in SiteSchemaJsonInfoDirectoriesAndSizesUploadsDirectory: required")
	}
	type Plain SiteSchemaJsonInfoDirectoriesAndSizesUploadsDirectory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDirectoriesAndSizesUploadsDirectory(plain)
	return nil
}

type SiteSchemaJsonInfoDirectoriesAndSizesWordpressDirectory struct {
	// Location corresponds to the JSON schema field "location".
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDirectoriesAndSizesWordpressDirectory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in SiteSchemaJsonInfoDirectoriesAndSizesWordpressDirectory: required")
	}
	if _, ok := raw["size"]; raw != nil && !ok {
		return fmt.Errorf("field size in SiteSchemaJsonInfoDirectoriesAndSizesWordpressDirectory: required")
	}
	type Plain SiteSchemaJsonInfoDirectoriesAndSizesWordpressDirectory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDirectoriesAndSizesWordpressDirectory(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoDirectoriesAndSizes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["databaseSize"]; raw != nil && !ok {
		return fmt.Errorf("field databaseSize in SiteSchemaJsonInfoDirectoriesAndSizes: required")
	}
	if _, ok := raw["pluginsDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field pluginsDirectory in SiteSchemaJsonInfoDirectoriesAndSizes: required")
	}
	if _, ok := raw["themesDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field themesDirectory in SiteSchemaJsonInfoDirectoriesAndSizes: required")
	}
	if _, ok := raw["totalInstallationSize"]; raw != nil && !ok {
		return fmt.Errorf("field totalInstallationSize in SiteSchemaJsonInfoDirectoriesAndSizes: required")
	}
	if _, ok := raw["uploadsDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field uploadsDirectory in SiteSchemaJsonInfoDirectoriesAndSizes: required")
	}
	if _, ok := raw["wordpressDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field wordpressDirectory in SiteSchemaJsonInfoDirectoriesAndSizes: required")
	}
	type Plain SiteSchemaJsonInfoDirectoriesAndSizes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoDirectoriesAndSizes(plain)
	return nil
}

type SiteSchemaJsonInfoFilesystemPermissions struct {
	// PluginsDirectory corresponds to the JSON schema field "pluginsDirectory".
	PluginsDirectory bool `json:"pluginsDirectory" yaml:"pluginsDirectory" mapstructure:"pluginsDirectory"`

	// ThemesDirectory corresponds to the JSON schema field "themesDirectory".
	ThemesDirectory bool `json:"themesDirectory" yaml:"themesDirectory" mapstructure:"themesDirectory"`

	// UploadsDirectory corresponds to the JSON schema field "uploadsDirectory".
	UploadsDirectory bool `json:"uploadsDirectory" yaml:"uploadsDirectory" mapstructure:"uploadsDirectory"`

	// WordpressDirectory corresponds to the JSON schema field "wordpressDirectory".
	WordpressDirectory bool `json:"wordpressDirectory" yaml:"wordpressDirectory" mapstructure:"wordpressDirectory"`

	// WpContentDirectory corresponds to the JSON schema field "wpContentDirectory".
	WpContentDirectory bool `json:"wpContentDirectory" yaml:"wpContentDirectory" mapstructure:"wpContentDirectory"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoFilesystemPermissions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pluginsDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field pluginsDirectory in SiteSchemaJsonInfoFilesystemPermissions: required")
	}
	if _, ok := raw["themesDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field themesDirectory in SiteSchemaJsonInfoFilesystemPermissions: required")
	}
	if _, ok := raw["uploadsDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field uploadsDirectory in SiteSchemaJsonInfoFilesystemPermissions: required")
	}
	if _, ok := raw["wordpressDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field wordpressDirectory in SiteSchemaJsonInfoFilesystemPermissions: required")
	}
	if _, ok := raw["wpContentDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field wpContentDirectory in SiteSchemaJsonInfoFilesystemPermissions: required")
	}
	type Plain SiteSchemaJsonInfoFilesystemPermissions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoFilesystemPermissions(plain)
	return nil
}

type SiteSchemaJsonInfoInactivePluginsElem struct {
	// Author corresponds to the JSON schema field "author".
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// AutoUpdates corresponds to the JSON schema field "autoUpdates".
	AutoUpdates bool `json:"autoUpdates" yaml:"autoUpdates" mapstructure:"autoUpdates"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoInactivePluginsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in SiteSchemaJsonInfoInactivePluginsElem: required")
	}
	if _, ok := raw["autoUpdates"]; raw != nil && !ok {
		return fmt.Errorf("field autoUpdates in SiteSchemaJsonInfoInactivePluginsElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SiteSchemaJsonInfoInactivePluginsElem: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SiteSchemaJsonInfoInactivePluginsElem: required")
	}
	type Plain SiteSchemaJsonInfoInactivePluginsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoInactivePluginsElem(plain)
	return nil
}

type SiteSchemaJsonInfoInactiveThemesElem struct {
	// Author corresponds to the JSON schema field "author".
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// AutoUpdates corresponds to the JSON schema field "autoUpdates".
	AutoUpdates bool `json:"autoUpdates" yaml:"autoUpdates" mapstructure:"autoUpdates"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoInactiveThemesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in SiteSchemaJsonInfoInactiveThemesElem: required")
	}
	if _, ok := raw["autoUpdates"]; raw != nil && !ok {
		return fmt.Errorf("field autoUpdates in SiteSchemaJsonInfoInactiveThemesElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SiteSchemaJsonInfoInactiveThemesElem: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SiteSchemaJsonInfoInactiveThemesElem: required")
	}
	type Plain SiteSchemaJsonInfoInactiveThemesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoInactiveThemesElem(plain)
	return nil
}

type SiteSchemaJsonInfoMediaHandling struct {
	// ActiveEditor corresponds to the JSON schema field "activeEditor".
	ActiveEditor string `json:"activeEditor" yaml:"activeEditor" mapstructure:"activeEditor"`

	// Whether file uploads are enabled
	FileUploads bool `json:"fileUploads" yaml:"fileUploads" mapstructure:"fileUploads"`

	// File formats supported by the GD library
	GdSupportedFormats []string `json:"gdSupportedFormats" yaml:"gdSupportedFormats" mapstructure:"gdSupportedFormats"`

	// Version of the GD image optimization library
	GdVersion string `json:"gdVersion" yaml:"gdVersion" mapstructure:"gdVersion"`

	// Version of the Ghostscript PDF rendering engine
	GhostscriptVersion *string `json:"ghostscriptVersion,omitempty" yaml:"ghostscriptVersion,omitempty" mapstructure:"ghostscriptVersion,omitempty"`

	// ImageMagickVersion corresponds to the JSON schema field "imageMagickVersion".
	ImageMagickVersion SiteSchemaJsonInfoMediaHandlingImageMagickVersion `json:"imageMagickVersion" yaml:"imageMagickVersion" mapstructure:"imageMagickVersion"`

	// ImagickVersion corresponds to the JSON schema field "imagickVersion".
	ImagickVersion string `json:"imagickVersion" yaml:"imagickVersion" mapstructure:"imagickVersion"`

	// Smaller of max post data size and max upload file size
	MaxEffectiveFileSize float64 `json:"maxEffectiveFileSize" yaml:"maxEffectiveFileSize" mapstructure:"maxEffectiveFileSize"`

	// Maximum number of files allowed in a single HTTP POST request
	MaxFilesAllowed int `json:"maxFilesAllowed" yaml:"maxFilesAllowed" mapstructure:"maxFilesAllowed"`

	// Maximum combined size of an HTTP POST request
	MaxPostDataSize float64 `json:"maxPostDataSize" yaml:"maxPostDataSize" mapstructure:"maxPostDataSize"`

	// Maximum size of a single uploaded file
	MaxUploadFileSize float64 `json:"maxUploadFileSize" yaml:"maxUploadFileSize" mapstructure:"maxUploadFileSize"`
}

type SiteSchemaJsonInfoMediaHandlingImageMagickVersion struct {
	// Number corresponds to the JSON schema field "number".
	Number int `json:"number" yaml:"number" mapstructure:"number"`

	// String corresponds to the JSON schema field "string".
	String string `json:"string" yaml:"string" mapstructure:"string"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoMediaHandlingImageMagickVersion) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["number"]; raw != nil && !ok {
		return fmt.Errorf("field number in SiteSchemaJsonInfoMediaHandlingImageMagickVersion: required")
	}
	if _, ok := raw["string"]; raw != nil && !ok {
		return fmt.Errorf("field string in SiteSchemaJsonInfoMediaHandlingImageMagickVersion: required")
	}
	type Plain SiteSchemaJsonInfoMediaHandlingImageMagickVersion
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoMediaHandlingImageMagickVersion(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoMediaHandling) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["activeEditor"]; raw != nil && !ok {
		return fmt.Errorf("field activeEditor in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["fileUploads"]; raw != nil && !ok {
		return fmt.Errorf("field fileUploads in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["gdSupportedFormats"]; raw != nil && !ok {
		return fmt.Errorf("field gdSupportedFormats in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["gdVersion"]; raw != nil && !ok {
		return fmt.Errorf("field gdVersion in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["imageMagickVersion"]; raw != nil && !ok {
		return fmt.Errorf("field imageMagickVersion in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["imagickVersion"]; raw != nil && !ok {
		return fmt.Errorf("field imagickVersion in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["maxEffectiveFileSize"]; raw != nil && !ok {
		return fmt.Errorf("field maxEffectiveFileSize in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["maxFilesAllowed"]; raw != nil && !ok {
		return fmt.Errorf("field maxFilesAllowed in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["maxPostDataSize"]; raw != nil && !ok {
		return fmt.Errorf("field maxPostDataSize in SiteSchemaJsonInfoMediaHandling: required")
	}
	if _, ok := raw["maxUploadFileSize"]; raw != nil && !ok {
		return fmt.Errorf("field maxUploadFileSize in SiteSchemaJsonInfoMediaHandling: required")
	}
	type Plain SiteSchemaJsonInfoMediaHandling
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoMediaHandling(plain)
	return nil
}

type SiteSchemaJsonInfoServerEnvironment struct {
	// CurlVersion corresponds to the JSON schema field "curlVersion".
	CurlVersion string `json:"curlVersion" yaml:"curlVersion" mapstructure:"curlVersion"`

	// HtaccessRules corresponds to the JSON schema field "htaccessRules".
	HtaccessRules []string `json:"htaccessRules" yaml:"htaccessRules" mapstructure:"htaccessRules"`

	// ImagickInstalled corresponds to the JSON schema field "imagickInstalled".
	ImagickInstalled bool `json:"imagickInstalled" yaml:"imagickInstalled" mapstructure:"imagickInstalled"`

	// MaxInputTime corresponds to the JSON schema field "maxInputTime".
	MaxInputTime float64 `json:"maxInputTime" yaml:"maxInputTime" mapstructure:"maxInputTime"`

	// MaxUploadFileSize corresponds to the JSON schema field "maxUploadFileSize".
	MaxUploadFileSize float64 `json:"maxUploadFileSize" yaml:"maxUploadFileSize" mapstructure:"maxUploadFileSize"`

	// PhpVariables corresponds to the JSON schema field "phpVariables".
	PhpVariables SiteSchemaJsonInfoServerEnvironmentPhpVariables `json:"phpVariables" yaml:"phpVariables" mapstructure:"phpVariables"`

	// PrettyPermalinksEnabled corresponds to the JSON schema field
	// "prettyPermalinksEnabled".
	PrettyPermalinksEnabled bool `json:"prettyPermalinksEnabled" yaml:"prettyPermalinksEnabled" mapstructure:"prettyPermalinksEnabled"`

	// ServerArchitecture corresponds to the JSON schema field "serverArchitecture".
	ServerArchitecture string `json:"serverArchitecture" yaml:"serverArchitecture" mapstructure:"serverArchitecture"`

	// SuhosinInstalled corresponds to the JSON schema field "suhosinInstalled".
	SuhosinInstalled bool `json:"suhosinInstalled" yaml:"suhosinInstalled" mapstructure:"suhosinInstalled"`

	// WebServer corresponds to the JSON schema field "webServer".
	WebServer string `json:"webServer" yaml:"webServer" mapstructure:"webServer"`
}

type SiteSchemaJsonInfoServerEnvironmentPhpVariables map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoServerEnvironment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["curlVersion"]; raw != nil && !ok {
		return fmt.Errorf("field curlVersion in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["htaccessRules"]; raw != nil && !ok {
		return fmt.Errorf("field htaccessRules in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["imagickInstalled"]; raw != nil && !ok {
		return fmt.Errorf("field imagickInstalled in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["maxInputTime"]; raw != nil && !ok {
		return fmt.Errorf("field maxInputTime in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["maxUploadFileSize"]; raw != nil && !ok {
		return fmt.Errorf("field maxUploadFileSize in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["phpVariables"]; raw != nil && !ok {
		return fmt.Errorf("field phpVariables in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["prettyPermalinksEnabled"]; raw != nil && !ok {
		return fmt.Errorf("field prettyPermalinksEnabled in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["serverArchitecture"]; raw != nil && !ok {
		return fmt.Errorf("field serverArchitecture in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["suhosinInstalled"]; raw != nil && !ok {
		return fmt.Errorf("field suhosinInstalled in SiteSchemaJsonInfoServerEnvironment: required")
	}
	if _, ok := raw["webServer"]; raw != nil && !ok {
		return fmt.Errorf("field webServer in SiteSchemaJsonInfoServerEnvironment: required")
	}
	type Plain SiteSchemaJsonInfoServerEnvironment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoServerEnvironment(plain)
	return nil
}

type SiteSchemaJsonInfoWordpress struct {
	// AllowRegistration corresponds to the JSON schema field "allowRegistration".
	AllowRegistration bool `json:"allowRegistration" yaml:"allowRegistration" mapstructure:"allowRegistration"`

	// CommunicationWithWordpressOrg corresponds to the JSON schema field
	// "communicationWithWordpressOrg".
	CommunicationWithWordpressOrg bool `json:"communicationWithWordpressOrg" yaml:"communicationWithWordpressOrg" mapstructure:"communicationWithWordpressOrg"`

	// DefaultCommentStatus corresponds to the JSON schema field
	// "defaultCommentStatus".
	DefaultCommentStatus string `json:"defaultCommentStatus" yaml:"defaultCommentStatus" mapstructure:"defaultCommentStatus"`

	// DiscouragingSearchEngines corresponds to the JSON schema field
	// "discouragingSearchEngines".
	DiscouragingSearchEngines bool `json:"discouragingSearchEngines" yaml:"discouragingSearchEngines" mapstructure:"discouragingSearchEngines"`

	// EnvironmentType corresponds to the JSON schema field "environmentType".
	EnvironmentType string `json:"environmentType" yaml:"environmentType" mapstructure:"environmentType"`

	// HomeUrl corresponds to the JSON schema field "homeUrl".
	HomeUrl string `json:"homeUrl" yaml:"homeUrl" mapstructure:"homeUrl"`

	// IsHttps corresponds to the JSON schema field "isHttps".
	IsHttps bool `json:"isHttps" yaml:"isHttps" mapstructure:"isHttps"`

	// IsMultisite corresponds to the JSON schema field "isMultisite".
	IsMultisite bool `json:"isMultisite" yaml:"isMultisite" mapstructure:"isMultisite"`

	// PermalinkStructure corresponds to the JSON schema field "permalinkStructure".
	PermalinkStructure string `json:"permalinkStructure" yaml:"permalinkStructure" mapstructure:"permalinkStructure"`

	// SiteLanguage corresponds to the JSON schema field "siteLanguage".
	SiteLanguage string `json:"siteLanguage" yaml:"siteLanguage" mapstructure:"siteLanguage"`

	// SiteUrl corresponds to the JSON schema field "siteUrl".
	SiteUrl string `json:"siteUrl" yaml:"siteUrl" mapstructure:"siteUrl"`

	// Timezone corresponds to the JSON schema field "timezone".
	Timezone string `json:"timezone" yaml:"timezone" mapstructure:"timezone"`

	// UserCount corresponds to the JSON schema field "userCount".
	UserCount int `json:"userCount" yaml:"userCount" mapstructure:"userCount"`

	// UserLanguage corresponds to the JSON schema field "userLanguage".
	UserLanguage string `json:"userLanguage" yaml:"userLanguage" mapstructure:"userLanguage"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

type SiteSchemaJsonInfoWordpressConstants struct {
	// Abspath corresponds to the JSON schema field "abspath".
	Abspath string `json:"abspath" yaml:"abspath" mapstructure:"abspath"`

	// ContentDirectory corresponds to the JSON schema field "contentDirectory".
	ContentDirectory string `json:"contentDirectory" yaml:"contentDirectory" mapstructure:"contentDirectory"`

	// DebuggingSettings corresponds to the JSON schema field "debuggingSettings".
	DebuggingSettings SiteSchemaJsonInfoWordpressConstantsDebuggingSettings `json:"debuggingSettings" yaml:"debuggingSettings" mapstructure:"debuggingSettings"`

	// MemoryLimit corresponds to the JSON schema field "memoryLimit".
	MemoryLimit string `json:"memoryLimit" yaml:"memoryLimit" mapstructure:"memoryLimit"`

	// PluginDirectory corresponds to the JSON schema field "pluginDirectory".
	PluginDirectory string `json:"pluginDirectory" yaml:"pluginDirectory" mapstructure:"pluginDirectory"`

	// WpHome corresponds to the JSON schema field "wpHome".
	WpHome string `json:"wpHome" yaml:"wpHome" mapstructure:"wpHome"`

	// WpSiteurl corresponds to the JSON schema field "wpSiteurl".
	WpSiteurl string `json:"wpSiteurl" yaml:"wpSiteurl" mapstructure:"wpSiteurl"`
}

type SiteSchemaJsonInfoWordpressConstantsDebuggingSettings map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoWordpressConstants) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["abspath"]; raw != nil && !ok {
		return fmt.Errorf("field abspath in SiteSchemaJsonInfoWordpressConstants: required")
	}
	if _, ok := raw["contentDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field contentDirectory in SiteSchemaJsonInfoWordpressConstants: required")
	}
	if _, ok := raw["debuggingSettings"]; raw != nil && !ok {
		return fmt.Errorf("field debuggingSettings in SiteSchemaJsonInfoWordpressConstants: required")
	}
	if _, ok := raw["memoryLimit"]; raw != nil && !ok {
		return fmt.Errorf("field memoryLimit in SiteSchemaJsonInfoWordpressConstants: required")
	}
	if _, ok := raw["pluginDirectory"]; raw != nil && !ok {
		return fmt.Errorf("field pluginDirectory in SiteSchemaJsonInfoWordpressConstants: required")
	}
	if _, ok := raw["wpHome"]; raw != nil && !ok {
		return fmt.Errorf("field wpHome in SiteSchemaJsonInfoWordpressConstants: required")
	}
	if _, ok := raw["wpSiteurl"]; raw != nil && !ok {
		return fmt.Errorf("field wpSiteurl in SiteSchemaJsonInfoWordpressConstants: required")
	}
	type Plain SiteSchemaJsonInfoWordpressConstants
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoWordpressConstants(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfoWordpress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["allowRegistration"]; raw != nil && !ok {
		return fmt.Errorf("field allowRegistration in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["communicationWithWordpressOrg"]; raw != nil && !ok {
		return fmt.Errorf("field communicationWithWordpressOrg in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["defaultCommentStatus"]; raw != nil && !ok {
		return fmt.Errorf("field defaultCommentStatus in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["discouragingSearchEngines"]; raw != nil && !ok {
		return fmt.Errorf("field discouragingSearchEngines in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["environmentType"]; raw != nil && !ok {
		return fmt.Errorf("field environmentType in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["homeUrl"]; raw != nil && !ok {
		return fmt.Errorf("field homeUrl in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["isHttps"]; raw != nil && !ok {
		return fmt.Errorf("field isHttps in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["isMultisite"]; raw != nil && !ok {
		return fmt.Errorf("field isMultisite in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["permalinkStructure"]; raw != nil && !ok {
		return fmt.Errorf("field permalinkStructure in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["siteLanguage"]; raw != nil && !ok {
		return fmt.Errorf("field siteLanguage in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["siteUrl"]; raw != nil && !ok {
		return fmt.Errorf("field siteUrl in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["timezone"]; raw != nil && !ok {
		return fmt.Errorf("field timezone in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["userCount"]; raw != nil && !ok {
		return fmt.Errorf("field userCount in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["userLanguage"]; raw != nil && !ok {
		return fmt.Errorf("field userLanguage in SiteSchemaJsonInfoWordpress: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SiteSchemaJsonInfoWordpress: required")
	}
	type Plain SiteSchemaJsonInfoWordpress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfoWordpress(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["activePlugins"]; raw != nil && !ok {
		return fmt.Errorf("field activePlugins in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["activeTheme"]; raw != nil && !ok {
		return fmt.Errorf("field activeTheme in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["customPostTypesAndTaxonomies"]; raw != nil && !ok {
		return fmt.Errorf("field customPostTypesAndTaxonomies in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["databaseConfiguration"]; raw != nil && !ok {
		return fmt.Errorf("field databaseConfiguration in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["databaseSchema"]; raw != nil && !ok {
		return fmt.Errorf("field databaseSchema in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["debugLog"]; raw != nil && !ok {
		return fmt.Errorf("field debugLog in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["directoriesAndSizes"]; raw != nil && !ok {
		return fmt.Errorf("field directoriesAndSizes in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["filesystemPermissions"]; raw != nil && !ok {
		return fmt.Errorf("field filesystemPermissions in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["inactivePlugins"]; raw != nil && !ok {
		return fmt.Errorf("field inactivePlugins in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["inactiveThemes"]; raw != nil && !ok {
		return fmt.Errorf("field inactiveThemes in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["mediaHandling"]; raw != nil && !ok {
		return fmt.Errorf("field mediaHandling in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["serverEnvironment"]; raw != nil && !ok {
		return fmt.Errorf("field serverEnvironment in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["wordpress"]; raw != nil && !ok {
		return fmt.Errorf("field wordpress in SiteSchemaJsonInfo: required")
	}
	if _, ok := raw["wordpressConstants"]; raw != nil && !ok {
		return fmt.Errorf("field wordpressConstants in SiteSchemaJsonInfo: required")
	}
	type Plain SiteSchemaJsonInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonInfo(plain)
	return nil
}

type SiteSchemaJsonStatus struct {
	// Critical issues related to security vulnerabilities or performance issues
	CriticalIssues []SiteSchemaJsonStatusCriticalIssuesElem `json:"criticalIssues" yaml:"criticalIssues" mapstructure:"criticalIssues"`

	// Passed tests with no issues
	PassedTests []SiteSchemaJsonStatusPassedTestsElem `json:"passedTests" yaml:"passedTests" mapstructure:"passedTests"`

	// Recommended improvements for better security and performance
	RecommendedImprovements []SiteSchemaJsonStatusRecommendedImprovementsElem `json:"recommendedImprovements" yaml:"recommendedImprovements" mapstructure:"recommendedImprovements"`
}

type SiteSchemaJsonStatusCriticalIssuesElem map[string]interface{}

type SiteSchemaJsonStatusPassedTestsElem map[string]interface{}

type SiteSchemaJsonStatusRecommendedImprovementsElem map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJsonStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["criticalIssues"]; raw != nil && !ok {
		return fmt.Errorf("field criticalIssues in SiteSchemaJsonStatus: required")
	}
	if _, ok := raw["passedTests"]; raw != nil && !ok {
		return fmt.Errorf("field passedTests in SiteSchemaJsonStatus: required")
	}
	if _, ok := raw["recommendedImprovements"]; raw != nil && !ok {
		return fmt.Errorf("field recommendedImprovements in SiteSchemaJsonStatus: required")
	}
	type Plain SiteSchemaJsonStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJsonStatus(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SiteSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["info"]; raw != nil && !ok {
		return fmt.Errorf("field info in SiteSchemaJson: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in SiteSchemaJson: required")
	}
	type Plain SiteSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SiteSchemaJson(plain)
	return nil
}
